[
    {
        "id": "76c152a4-c852-4811-9d23-bbb31499c7f9",
        "chapter": "guided-tour",
        "section": "OCaml as a Calculator",
        "type": "multiple_choice",
        "question": "Which of the following statements about OCaml's numeric types is NOT true?",
        "choices": [
            "A) OCaml distinguishes between integers and floating-point numbers.",
            "B) OCaml automatically converts integers to floating-point numbers.",
            "C) OCaml requires different operators for integer and floating-point arithmetic.",
            "D) OCaml allows underscores in numeric literals."
        ],
        "correct_answers": [
            1
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "The correct answer is B) OCaml does not automatically convert integers to floating-point numbers, which can prevent certain bugs common in other languages. In OCaml, one must be explicit when operating with different numeric types.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "b8137094-357a-4e9e-a2f8-24ff9ef99bfc",
        "chapter": "guided-tour",
        "section": "OCaml as a Calculator",
        "type": "multiple_choice",
        "question": "What must you type at the end of an expression in the OCaml toplevel to indicate evaluation?",
        "choices": [
            "A) .",
            "B) ;",
            "C) :",
            "D) ( )"
        ],
        "correct_answers": [
            1
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "The correct answer is B) In OCaml, you must type ';' to indicate the end of an expression for it to be evaluated in the toplevel.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "c80021e4-0495-4a4d-89af-c254d514c198",
        "chapter": "guided-tour",
        "section": "OCaml as a Calculator",
        "type": "programming",
        "question": "Implement a function in OCaml that takes a list of integers and returns a new list where each integer is squared. Ensure that the implementation uses best practices with types and immutability.",
        "choices": [],
        "correct_answers": [],
        "starter_code": "let square_list lst =  \n    (* Your code here to square each element of the list *)\n",
        "test_code": "let () =\n    let result = square_list [1; 2; 3; 4];;\n    List.iter (Printf.printf \"%d \") result;; (* should print 1 4 9 16 *)\n\nlet () =\n    let result = square_list [-1; -2; -3];;\n    List.iter (Printf.printf \"%d \") result;; (* should print 1 4 9 *)",
        "hint": "Use List.map to apply the squaring function to each element of the list. Use the power operator ( ** ) to square the integers.",
        "explanation": "This problem tests knowledge of lists and higher-order functions in OCaml. OCaml's immutability means you will need to create a new list rather than modifying the existing one. This is an opportunity to explore list manipulation in OCaml.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "25a9ac36-8dd3-4390-903e-898f10cda69a",
        "chapter": "guided-tour",
        "section": "Functions and Type Inference",
        "type": "multiple_choice",
        "question": "What is the purpose of the `let open` syntax in OCaml?",
        "choices": [
            "A) To bind variables",
            "B) To create a new module",
            "C) To bring a module's functions into scope",
            "D) To define a new type"
        ],
        "correct_answers": [
            2
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "The `let open` syntax allows you to bring all the functions and types from a module into the current scope so you can use them without prefixing with the module name. This can simplify code and make it more readable.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "000efa70-ce58-4db2-a079-f41988841c64",
        "chapter": "guided-tour",
        "section": "Functions and Type Inference",
        "type": "multiple_choice",
        "question": "What does the type `int -> int -> float` signify in OCaml?",
        "choices": [
            "A) A function that takes an integer and returns an integer",
            "B) A function that takes two integers and returns an integer",
            "C) A function that takes two integers and returns a float",
            "D) A function that returns a float without any arguments"
        ],
        "correct_answers": [
            2
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "The type `int -> int -> float` describes a function that takes two arguments of type `int` and returns a value of type `float`. It reflects how OCaml functions can have types that indicate their input and output.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "8deeb550-ce77-4eb7-9ba6-9258a93c34fe",
        "chapter": "guided-tour",
        "section": "Functions and Type Inference",
        "type": "programming",
        "question": "Implement a function `sum_if_greater_than` that takes an integer and a list of integers, returning the sum of the integers that are greater than the specified integer.",
        "choices": [],
        "correct_answers": [],
        "starter_code": "let sum_if_greater_than threshold lst = \n    (* your code here *)\n",
        "test_code": "let () =  \n    let result1 = sum_if_greater_than 5 [1; 6; 3; 7; 2];;  (* should return 13 *)  \n    let result2 = sum_if_greater_than 3 [1; 2; 3; 4];;  (* should return 4 *)  \n    let result3 = sum_if_greater_than 0 [1; -1; 2; -2];;  (* should return 3 *)  \n    let result4 = sum_if_greater_than 10 [5; 10; 15];;  (* should return 15 *)  \n",
        "hint": "Use List.fold_left to iterate through the list while checking each element against the threshold and accumulating the sum of those that are greater.",
        "explanation": "This function illustrates how to use List.fold_left to traverse a list while applying a condition to filter which values contribute to the accumulated result. You should look into other functional programming techniques to manipulate lists and conditionally accumulate values.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "a1c19031-99b8-47e7-a4ed-a607cb84f710",
        "chapter": "guided-tour",
        "section": "Type Inference",
        "type": "multiple_choice",
        "question": "What is the purpose of type inference in OCaml?",
        "choices": [
            "A) To explicitly define types for all variables",
            "B) To allow the compiler to automatically determine the types of expressions",
            "C) To improve execution speed by reducing type checks",
            "D) To enable dynamic typing in a statically typed language"
        ],
        "correct_answers": [
            1
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "Type inference allows OCaml to deduce the types of expressions without requiring the programmer to specify them, simplifying code writing and improving readability.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "1b5c4491-a7a0-4da6-a17d-bbe6e03defb4",
        "chapter": "guided-tour",
        "section": "Type Inference",
        "type": "multiple_choice",
        "question": "In the function 'sum_if_true', which of the following statements about the type of 'test' is correct?",
        "choices": [
            "A) It must take an int and return a string",
            "B) It can accept any type of input",
            "C) It must take an int and return a bool",
            "D) It must take two ints and return a bool"
        ],
        "correct_answers": [
            2
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "The 'test' function in 'sum_if_true' is called with integers, which must return a boolean value, therefore its type is correctly inferred to be int -> bool.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "3898a5d7-22df-4fce-a7d6-d390954d84a8",
        "chapter": "guided-tour",
        "section": "Type Inference",
        "type": "programming",
        "question": "Implement a function `sum_if_true` that takes a predicate function and two integers. The function should return the sum of the integers if they satisfy the predicate; otherwise, return 0 for those that do not satisfy it.",
        "choices": [],
        "correct_answers": [],
        "starter_code": "let sum_if_true (test : int -> bool) (x : int) (y : int) : int =\n    (* Your code here *)",
        "test_code": "let () =\n    (* Example cases *)\n    let result1 = sum_if_true (fun n -> n > 0) 3 4 in\n    print_int result1; (* Should print 7 *)\n\n    let result2 = sum_if_true (fun n -> n < 0) (-3) 4 in\n    print_int result2; (* Should print 0 *)\n\n    let result3 = sum_if_true (fun n -> n mod 2 = 0) 4 5 in\n    print_int result3; (* Should print 4 *)\n",
        "hint": "Use an if-else expression to check the predicate for each integer before adding them together.",
        "explanation": "The challenge of this question lies in properly structuring the if-else logic to check each integer against the predicate and summing them accordingly. It reinforces the understanding of functional programming and higher-order functions in OCaml.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "2e91e765-718a-44ad-bb24-f50e75be4a74",
        "chapter": "guided-tour",
        "section": "Inferring Generic Types",
        "type": "multiple_choice",
        "question": "What does the function 'first_if_true' return if the test function evaluates to false?",
        "choices": [
            "The first input argument",
            "The second input argument",
            "The output of the test function",
            "None of the above"
        ],
        "correct_answers": [
            1
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "Consider what happens when the test condition isn't met.",
        "explanation": "The function 'first_if_true' takes a test function, and based on the test result, it returns either the first or the second argument it receives. If the test function evaluates to false for the first argument, it returns the second one.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "44c8bdaa-86f4-4de8-b4ed-147b67d30c61",
        "chapter": "guided-tour",
        "section": "Inferring Generic Types",
        "type": "multiple_choice",
        "question": "What type of error is raised when attempting to divide by zero in the function 'is_a_multiple'?",
        "choices": [
            "Type Error",
            "Runtime Exception",
            "Compile Time Error",
            "Syntax Error"
        ],
        "correct_answers": [
            1
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "Think about when the error is detected by the OCaml compiler versus when it's detected during execution.",
        "explanation": "The division by zero leads to a runtime exception because it occurs only when the function 'is_a_multiple' is executed with a zero as the second argument. This type of error cannot be caught by the type system during compilation.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "2499d230-4c49-41a8-991c-fa56c4f6a837",
        "chapter": "guided-tour",
        "section": "Inferring Generic Types",
        "type": "programming",
        "question": "Implement a generic function 'first_if_true' in OCaml that takes a predicate and two values, returning the first value if the predicate is true for that value, otherwise returning the second value. Additionally, create a version of this function that allows for a default value when both inputs do not match the predicate's type.",
        "choices": [],
        "correct_answers": [],
        "starter_code": "let first_if_true test x y = if test x then x else y\n(* Your task is to extend this function to support a default value *)",
        "test_code": "let () = (\n  let is_even n = n mod 2 = 0 in\n  let res1 = first_if_true is_even 4 5 in\n  let res2 = first_if_true is_even 3 5 in\n  (* Expected output: 4 *)\n  Printf.printf \"Result 1: %d\\n\" res1;\n  (* Expected output: 5 *)\n  Printf.printf \"Result 2: %d\\n\" res2;\n)",
        "hint": "You will need to handle type variables and ensure the default value is accepted for both types x and y. Consider utilizing polymorphic behavior.",
        "explanation": "The 'first_if_true' function demonstrates parametric polymorphism, allowing it to work with any types as long as they match. When extending the function to include a default value, think about how to accommodate cases where the input types do not match the expected type specified in the function definition. You could use option types or an additional parameter to handle this.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "e2cd73c3-b120-4816-bebc-4e0af817117e",
        "chapter": "guided-tour",
        "section": "Tuples, Lists, Options, and Pattern Matching",
        "type": "multiple_choice",
        "question": "What is the purpose of the `List.map` function in OCaml?",
        "choices": [
            "A) To compute the length of a list",
            "B) To concatenate two lists",
            "C) To transform elements of a list using a given function",
            "D) To reverse the order of elements in a list"
        ],
        "correct_answers": [
            2
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "The `List.map` function takes a list and a function, applies the function to each element of the list, and returns a new list with the results. This allows you to perform transformations without mutating the original list.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "4404ae82-c5ad-4d4e-887f-a422f34c2309",
        "chapter": "guided-tour",
        "section": "Tuples, Lists, Options, and Pattern Matching",
        "type": "multiple_choice",
        "question": "Which operator is used for float exponentiation in the Base library?",
        "choices": [
            "A) ^",
            "B) **",
            "C) **. ",
            "D) **^"
        ],
        "correct_answers": [
            2
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "In the Base library, the **. operator is specifically used for floating-point exponentiation. It's important to distinguish it from the integer exponentiation operator.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "cfe9c410-ac63-4b5c-b43c-93dfbc0ec1ec",
        "chapter": "guided-tour",
        "section": "Tuples, Lists, Options, and Pattern Matching",
        "type": "programming",
        "question": "Implement a function `remove_adjacent_duplicates` that takes a list of integers and returns a new list without consecutive duplicate elements. For example, given the input `[1; 1; 2; 2; 3; 1; 1]`, it should return `[1; 2; 3; 1]`.",
        "choices": [],
        "correct_answers": [],
        "starter_code": "let rec remove_adjacent_duplicates lst =\n  (* Your code here *)\n",
        "test_code": "let () =\n  let result1 = remove_adjacent_duplicates [1; 1; 2; 2; 3; 1; 1] in\n  List.iter print_int result1; (* should print 1 2 3 1 *)\n  let result2 = remove_adjacent_duplicates [4; 4; 4; 5] in\n  List.iter print_int result2; (* should print 4 5 *)\n  let result3 = remove_adjacent_duplicates [] in\n  List.iter print_int result3; (* should print nothing, as it's empty *)\n",
        "hint": "Use pattern matching to check if the list is empty or if it contains one or more elements. You will also need to compare the head of the list with its tail to determine if duplicates exist.",
        "explanation": "To solve this problem, you should handle the list recursively. If the list is empty or has one element, return it. Otherwise, compare the first element with the second to check for duplicates. If they are the same, skip the first element; otherwise, keep it.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "24725108-6193-4bbd-ab38-f2ba0b3b5951",
        "chapter": "guided-tour",
        "section": "Tuples",
        "type": "multiple_choice",
        "question": "What does the `distance` function calculate in OCaml when given two tuples representing points?",
        "choices": [
            "A) The Manhattan distance",
            "B) The Euclidean distance",
            "C) The Chebyshev distance",
            "D) The Hamming distance"
        ],
        "correct_answers": [
            1
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "The `distance` function calculates the Euclidean distance between two points on a plane represented as tuples. This is evidenced by the formula that involves the square root of the sum of the squares of the differences in their coordinates.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "70dd40e5-eb70-4501-887f-67f927acaba3",
        "chapter": "guided-tour",
        "section": "Tuples",
        "type": "multiple_choice",
        "question": "In OCaml's Base library, which operator is specifically used for raising a floating-point number to a power?",
        "choices": [
            "A) ^",
            "B) **",
            "C) **.",
            "D) pow"
        ],
        "correct_answers": [
            2
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "In OCaml's Base library, the operator for raising a floating-point number to a power is `**.`. This helps distinguish between float and integer operations in the language.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "9cd5b811-e2a4-4f4b-9eae-b5b2c5a2aca9",
        "chapter": "guided-tour",
        "section": "Tuples",
        "type": "programming",
        "question": "Implement a function that takes a tuple of coordinates representing two points and computes the Euclidean distance between them.",
        "choices": [],
        "correct_answers": [],
        "starter_code": "let distance (p1 : float * float) (p2 : float * float) =\n    (* your code here *)\n",
        "test_code": "let () =\n    print_float (distance (3.0, 4.0) (0.0, 0.0));; (* should return 5.0 *)\n    print_float (distance (1.0, 1.0) (4.0, 5.0));; (* should return 5.0 *)",
        "hint": "Use the formula for Euclidean distance sqrt((x1 - x2)^2 + (y1 - y2)^2). Consider using the operators from the Base library for floats.",
        "explanation": "The Euclidean distance is calculated using the square of the differences in x and y coordinates. Ensure to use `Float.sqrt` for the square root and `Float.( **. )` for floating-point exponentiation.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "7f8c4cdd-2c69-41f5-961f-bb73291744f5",
        "chapter": "guided-tour",
        "section": "Lists",
        "type": "multiple_choice",
        "question": "What is the correct way to construct a list in OCaml using the :: operator?",
        "choices": [
            "A) 1 :: 2 :: 3 ;;",
            "B) [1; 2; 3] ;;",
            "C) 1, 2, 3 ;;",
            "D) [1; 2; 3; 4] :: [5] ;;"
        ],
        "correct_answers": [
            0
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "Remember that the :: operator adds an element to the front of a list. Lists in OCaml are constructed either with [] or by using :: with empty lists to denote the end.",
        "explanation": "The correct answer is A) 1 :: 2 :: 3 ;; which evaluates to [1; 2; 3]. Option B is correct but uses brackets instead of the :: operator, while option C creates a tuple. Option D would not compile as it looks to add two lists improperly.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "0e038e3a-5397-499a-8fcf-601a637273a7",
        "chapter": "guided-tour",
        "section": "Lists",
        "type": "multiple_choice",
        "question": "What will happen if you run the following code: List.map ~f:String.length languages where languages is defined as ['OCaml', 'Perl', 'C']?",
        "choices": [
            "A) It will raise an exception.",
            "B) It will return [5; 4; 1].",
            "C) It will return ['OCaml'; 'Perl', 'C'].",
            "D) It will not compile."
        ],
        "correct_answers": [
            1
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "Ensure to check that 'languages' is defined correctly as a list of strings before calling the function.",
        "explanation": "The code will return B) [5; 4; 1] because String.length is applied to each string in the list, returning their lengths. The list must be defined correctly to avoid an exception.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "b7a76dbf-0dea-48a5-a584-7c21e952f7bc",
        "chapter": "guided-tour",
        "section": "Lists",
        "type": "programming",
        "question": "Implement a function that removes all sequential duplicates from a list of integers. The function should handle the case of single-element lists and empty lists properly.",
        "choices": [],
        "correct_answers": [],
        "starter_code": "let rec remove_sequential_duplicates list =\n  match list with\n  | [] -> []\n  | x :: y :: tl ->\n      if x = y then\n        remove_sequential_duplicates (y :: tl)\n      else\n        x :: remove_sequential_duplicates (y :: tl)\n  | [x] -> [x] (* add this case to handle single-element lists *)",
        "test_code": "let () = remove_sequential_duplicates [1; 1; 2; 3; 3; 4; 4; 1; 1];; (* should return [1; 2; 3; 4; 1] *)\nlet () = remove_sequential_duplicates [] ;; (* should return [] *)\nlet () = remove_sequential_duplicates [5];; (* should return [5] *)",
        "hint": "Use pattern matching to differentiate between an empty list, a single-element list, and lists with two or more elements. Remember to handle the case of comparing the head and next element properly.",
        "explanation": "The provided function effectively removes sequential duplicates by checking if the first two elements are equal. If they are, it skips the first and continues with the next. If they are not, it includes the first in the result and recurses on the tail. This handles all required scenarios, maintaining the order of first appearances.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "c203643c-19c4-4c1c-898f-696d6877b0ed",
        "chapter": "guided-tour",
        "section": "Options",
        "type": "multiple_choice",
        "question": "What is the return type of the function `String.rsplit2` in OCaml?",
        "choices": [
            "A) string",
            "B) string option",
            "C) (string * string) option",
            "D) (string * string)"
        ],
        "correct_answers": [
            2
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "The correct answer is C) (string * string) option. `String.rsplit2` returns an option type that either contains a tuple of two strings if the split was successful or None if no delimiter was found.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "75a21b7b-2390-4178-aec2-15565b3c0573",
        "chapter": "guided-tour",
        "section": "Options",
        "type": "multiple_choice",
        "question": "Which of the following statements about Options in OCaml is true?",
        "choices": [
            "A) An option can contain multiple values.",
            "B) You can use the `None` constructor to represent a missing value.",
            "C) Options can only store integer data types.",
            "D) Options are equivalent to nullable types in other languages."
        ],
        "correct_answers": [
            1
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "The correct answer is B) You can use the `None` constructor to represent a missing value. Options in OCaml are specifically designed to communicate that a value may or may not be present, distinguishing them from the concept of nullable types.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "cc79414f-6603-494e-8772-16c87d91840a",
        "chapter": "guided-tour",
        "section": "Options",
        "type": "programming",
        "question": "Implement a function `safe_divide` that divides two integers, returning an option type. The function should return `None` if the divisor is zero, otherwise return `Some` of the result.",
        "choices": [],
        "correct_answers": [],
        "starter_code": "let safe_divide x y =\n    (* your code here *)",
        "test_code": "let () =\n    match safe_divide 10 2 with\n    | None -> print_endline \"Division failed\"\n    | Some result -> Printf.printf \"Result: %d\\n\" result; (* should print \"Result: 5\" *)\n\n    match safe_divide 10 0 with\n    | None -> print_endline \"Division failed\"; (* should print \"Division failed\" *)\n    | Some result -> Printf.printf \"Result: %d\\n\" result;",
        "hint": "Consider using an if statement to check if the divisor is zero, and return None or Some of the division result accordingly.",
        "explanation": "To solve this problem, you'll need to make use of the option type in OCaml. It's a fundamental part of handling potentially undefined values, which avoids common pitfalls such as null references. Starting with pattern matching on the option type could also lead to more nuanced error handling and further exploration of the Option module.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "4beed425-2b5b-43d4-a258-513eab3832d5",
        "chapter": "guided-tour",
        "section": "Records and Variants",
        "type": "multiple_choice",
        "question": "What is the primary difference between records and tuples in OCaml?",
        "choices": [
            "A) Records can have named fields, tuples cannot",
            "B) Records are always immutable, while tuples can be modified",
            "C) Tuples can only contain elements of the same type, records can contain different types",
            "D) Records must be defined positionally, while tuples are defined by field names"
        ],
        "correct_answers": [
            0
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "Think about how data structures allow access to their stored values.",
        "explanation": "Records, unlike tuples, allow access to stored values through named fields, making them more readable and easier to work with. This characteristic distinguishes them from tuples, which are defined positionally.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "b6c937b2-4e9c-4a28-9759-421bd676e75e",
        "chapter": "guided-tour",
        "section": "Records and Variants",
        "type": "multiple_choice",
        "question": "In the function 'is_inside_scene_element', which case requires the calculation of distance from the point to the element's center?",
        "choices": [
            "A) Circle",
            "B) Rect",
            "C) Segment",
            "D) None of the above"
        ],
        "correct_answers": [
            0
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "Look for the geometric shape that involves a center point.",
        "explanation": "The 'Circle' case involves determining if a point lies within a circle's radius, requiring a distance calculation from the point to the circle's center.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "10322c94-4191-426f-8a04-3b188d9a8e86",
        "chapter": "guided-tour",
        "section": "Records and Variants",
        "type": "programming",
        "question": "Implement a function that takes a 'scene_element list' and returns a list of points that are inside all elements of the scene. Use the previously defined 'is_inside_scene' function to check each point.",
        "choices": [],
        "correct_answers": [],
        "starter_code": "(* Your task is to complete this function *)\nlet points_inside_scene (points: point2d list) (scene: scene_element list) =\n  (* your code here *)\n",
        "test_code": "let scene = [ \n    Circle {center = {x=4.; y=4.}; radius=5.};\n    Rect {lower_left = {x=3.; y=3.}; width=5.; height=5.}\n];\n\n(* Example points *)\nlet points = [\n    {x=5.; y=5.};  (* Inside circle and rectangle *)\n    {x=10.; y=10.};  (* Outside both *)\n    {x=4.; y=4.};  (* Inside circle *)\n];\n\nlet () = \n  points_inside_scene points scene\n  |> List.iter ~f:(fun pt -> (* check inside logic for each point *)\n    print_s [%string \"Point (%{float} , %{float}) is inside: %{bool}\" pt.x pt.y (is_inside_scene pt scene)]\n  ); (* Should display whether points are inside the scene or not *)\n",
        "hint": "Utilize the is_inside_scene function to check each point against the scene elements.",
        "explanation": "The task is about filtering points that lie within any shape in the scene. You can build on the existing 'is_inside_scene' logic to achieve this. Consider iterating over each point and using the 'is_inside_scene' function to create a list of points that are confirmed as inside the scene.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "4223fd59-cfb0-4bde-9855-91a1e7ce1a9f",
        "chapter": "guided-tour",
        "section": "Imperative Programming",
        "type": "multiple_choice",
        "question": "What is the purpose of the 'mutable' keyword in OCaml?",
        "choices": [
            "A) To declare immutable data structures",
            "B) To declare mutable variables or fields in records",
            "C) To enable garbage collection",
            "D) To optimize function execution speed"
        ],
        "correct_answers": [
            1
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "The 'mutable' keyword in OCaml allows you to declare variables or fields that can be modified after they are initialized. This is particularly useful for creating data structures like records that can have some fields alter their values.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "1af91d4b-9805-4bce-a353-cb2f4e773ada",
        "chapter": "guided-tour",
        "section": "Imperative Programming",
        "type": "multiple_choice",
        "question": "In the context of imperative programming, what does the function 'List.iter' do?",
        "choices": [
            "A) Transforms a list into a single value",
            "B) Executes a provided function on each element of the list",
            "C) Filters elements of a list based on a condition",
            "D) Reverses the order of elements in a list"
        ],
        "correct_answers": [
            1
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "The 'List.iter' function in OCaml is used to apply a function to each element of a list side-effectively. This means that it does not accumulate a result but rather performs actions based on each element that is processed.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "677cbecb-e88f-405a-a412-363711f830ab",
        "chapter": "guided-tour",
        "section": "Imperative Programming",
        "type": "programming",
        "question": "Implement a function that calculates the sum of squares of an integer array using imperative programming constructs in OCaml. The function should modify a mutable reference that accumulates the total sum of squares.",
        "choices": [],
        "correct_answers": [],
        "starter_code": "let sum_of_squares arr =\n    let total = ref 0 in\n    Array.iter (fun x -> total := !total + (x * x)) arr;\n    !total;",
        "test_code": "let () =\n    let result1 = sum_of_squares [|1; 2; 3|] in\n    let () = Js.log result1 in (* Expected output: 14 *)\n    let result2 = sum_of_squares [|0; -5; 5|] in\n    let () = Js.log result2 in (* Expected output: 50 *)",
        "hint": "Consider how to use a mutable reference to accumulate the sum as you iterate through the array elements.",
        "explanation": "In this implementation, we use a mutable reference to keep track of the cumulative sum of the squares of the integers in the input array. Mutability allows us to modify 'total' directly as we process each element.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "dc706bb3-af98-45eb-9161-8e840b435e83",
        "chapter": "guided-tour",
        "section": "Arrays",
        "type": "multiple_choice",
        "question": "What is the purpose of the \"<-\" syntax in OCaml arrays?",
        "choices": [
            "A) To access an element",
            "B) To create an array",
            "C) To modify an element",
            "D) To delete an element"
        ],
        "correct_answers": [
            2
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "Think about how you change the value of an element in an array.",
        "explanation": "The \"<-\" syntax is used to modify an element in an OCaml array. For example, if you have an array and you want to change the value of the third element, you would use this syntax. It is important to note that the indexing of arrays starts from zero in OCaml.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "9114a5ff-a0ba-40c1-8885-7ff155438efc",
        "chapter": "guided-tour",
        "section": "Arrays",
        "type": "multiple_choice",
        "question": "Which of the following statements about OCaml arrays is true?",
        "choices": [
            "A) They are immutable by default",
            "B) Indexing starts at 1",
            "C) They are more memory efficient than lists",
            "D) They are similar to linked lists"
        ],
        "correct_answers": [
            2
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "Consider how arrays compare to other data structures in terms of memory usage and mutability.",
        "explanation": "OCaml arrays are mutable, meaning their elements can be changed, and they are more compact in terms of memory utilization than lists. This makes them efficient for certain operations that require frequent updates.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "98fb6c3e-790a-4c54-b8ed-2d42d7bc3877",
        "chapter": "guided-tour",
        "section": "Arrays",
        "type": "programming",
        "question": "Implement a function that takes an array of integers and returns a new array containing the squares of the original elements.",
        "choices": [],
        "correct_answers": [],
        "starter_code": "let square_array arr = \n    (* your code here *)\n",
        "test_code": "let () = \n    square_array [| 1; 2; 3; 4 |];; (* should return [| 1; 4; 9; 16 | *)\n    square_array [| -1; 0; 5 |];; (* should return [| 1; 0; 25 | *)\n    square_array [| 0; 2; -3; -4 |];; (* should return [| 0; 4; 9; 16 | *)\n",
        "hint": "You will need to create a new array and iterate over the input array to square each element. Remember to handle the size of the array carefully.",
        "explanation": "This problem requires you to understand how to manipulate arrays in OCaml. You need to create a new array as you cannot modify the input array directly. Use a loop or recursive function to go through each element, square it, and place it in the new array. Explore also how to use the Array.create function to initialize your new array.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "42572bee-eb91-487c-8c34-24d8647a82bd",
        "chapter": "guided-tour",
        "section": "Mutable Record Fields",
        "type": "multiple_choice",
        "question": "What does the `update` function do in the context of the `running_sum` record?",
        "choices": [
            "A) It resets the fields of the running_sum to zero",
            "B) It adds a new sample to the running sum, updating sum, sum_sq and samples",
            "C) It calculates the mean of the samples",
            "D) It creates a new running_sum record with the given values"
        ],
        "correct_answers": [
            1
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "Focus on how the fields within the running_sum record are modified when a new sample is added.",
        "explanation": "The `update` function takes an existing `running_sum` record and a new number, updating the `sum`, `sum_sq`, and the count of `samples`. This is critical for maintaining an accurate statistical summary.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "26ecdffd-8a06-4fe5-b357-bf09348c970b",
        "chapter": "guided-tour",
        "section": "Mutable Record Fields",
        "type": "multiple_choice",
        "question": "Why is the `mean` function defined in terms of mutable fields of the `running_sum` record?",
        "choices": [
            "A) It needs to modify the original running_sum",
            "B) It collects data to compute statistics from previous updates",
            "C) It is inefficient and requires less precision",
            "D) It doesn't need to use mutable states"
        ],
        "correct_answers": [
            1
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "Think about how statistical calculations typically require access to aggregated data over time.",
        "explanation": "The `mean` function computes the average based on cumulative values in a `running_sum`, which relies on data collected incrementally. Mutable fields allow for efficient updates without creating new records for each sample.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "a996bf8e-9846-4f01-b644-51f3b3791cc4",
        "chapter": "guided-tour",
        "section": "Mutable Record Fields",
        "type": "programming",
        "question": "Implement a function `variance` that computes the variance of the samples stored in the `running_sum` record. Variance is defined as the average of the squared differences from the Mean.\n\nThe formula for variance is: variance = (sum_of_squares / count) - (mean * mean).",
        "choices": [],
        "correct_answers": [],
        "starter_code": "let variance rsum = \n  let m = mean rsum in\n  (rsum.sum_sq /. Float.of_int rsum.samples) -. (m ** 2.);;",
        "test_code": "let rsum = create () in\nList.iter [1.; 3.; 2.; -7.; 4.; 5.] ~f:(fun x -> update rsum x);\nlet var = variance rsum in\n(* Expected Output: 15.5 *)\nlet mean_value = mean rsum in\n(* Expected Output: 1.3333333333333333 *)\nlet stdev_value = stdev rsum in\n(* Expected Output: 3.944053188733077 *)",
        "hint": "Ensure to calculate the mean first, as it's required to compute variance. Remember the significance of mutable state in retaining the summary statistics.",
        "explanation": "The `variance` function computes the variance based on current statistics in the `running_sum`. By reusing the `mean` function, it ensures computations remain efficient, relying on previously calculated means and sums of squares.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "c9945aac-3068-44e0-815b-e6667316ec8c",
        "chapter": "guided-tour",
        "section": "Refs",
        "type": "multiple_choice",
        "question": "What does the `!` operator do in OCaml when used with refs?",
        "choices": [
            "A) Changes the value of the ref",
            "B) Retrieves the value from the ref",
            "C) Creates a new ref",
            "D) Initializes a ref with a value"
        ],
        "correct_answers": [
            1
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "The `!` operator dereferences the ref, retrieving the value stored in `contents`. This is crucial for working with refs as it allows access to the mutable value.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "99af9095-db23-4084-b1cf-89bbb8a125c8",
        "chapter": "guided-tour",
        "section": "Refs",
        "type": "multiple_choice",
        "question": "What is the purpose of the `:=` operator in OCaml?",
        "choices": [
            "A) To multiply values",
            "B) To retrieve values from refs",
            "C) To assign a new value to a ref",
            "D) To create a ref"
        ],
        "correct_answers": [
            2
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "The `:=` operator is used to assign a new value to the contents of a ref. This allows for mutable state management, which is a key feature when using refs in OCaml.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "79300616-a34e-4cee-ac29-9c875fb1c823",
        "chapter": "guided-tour",
        "section": "Refs",
        "type": "programming",
        "question": "Implement a function that takes a list of integers and returns their product using refs for mutable state. Ensure the function iterates through elements and updates the mutable product value accordingly.",
        "choices": [],
        "correct_answers": [],
        "starter_code": "let product list =\n    (* your code here *)\n",
        "test_code": "let () = \n    let p1 = product [1; 2; 3; 4] in\n    (* should return 24 *);;\n    let p2 = product [0; 5; 10] in\n    (* should return 0 *);;\n    let p3 = product [2; -3; 4] in\n    (* should return -24 *);;",
        "hint": "Use a ref to keep track of the current product and update it as you iterate through the list. Remember to initialize the product to 1 and to dereference the ref to retrieve the current product value.",
        "explanation": "The product function uses a mutable ref to maintain the running product of the list elements. By iterating with List.iter, it ensures each element is multiplied into the accumulated product. This exercise showcases how mutable state can be beneficial for certain algorithms.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "243fb51d-8ce7-4814-93b9-6064b27e4058",
        "chapter": "guided-tour",
        "section": "For and While Loops",
        "type": "multiple_choice",
        "question": "What is the purpose of the `Random` module in the permutation example provided?",
        "choices": [
            "A) To generate random numbers for swapping elements",
            "B) To sort the array in random order",
            "C) To initialize the array with random values",
            "D) To reset the permutation each time"
        ],
        "correct_answers": [
            0
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "The `Random` module is used in the permutation example to generate random indices for swapping array elements, thereby achieving a random permutation of the array elements. This is fundamental in implementing algorithms that require randomization, such as Shuffle.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "74ead79a-b673-418d-a4df-34213090fc1d",
        "chapter": "guided-tour",
        "section": "For and While Loops",
        "type": "multiple_choice",
        "question": "What does the `find_first_negative_entry` function return when there are no negative entries in the array?",
        "choices": [
            "A) Some 0",
            "B) A reference to the last index",
            "C) None",
            "D) Some -1"
        ],
        "correct_answers": [
            2
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "The `find_first_negative_entry` function returns None when there are no negative entries, indicating that the search was unsuccessful. It uses the reference `pos` to track the position as it checks elements in the array.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "f57b2b45-c534-4e7f-a112-93e4cc180cb0",
        "chapter": "guided-tour",
        "section": "For and While Loops",
        "type": "programming",
        "question": "Implement a function that checks if an array of integers contains any duplicate values. If duplicates are found, return `true`; otherwise, return `false`.",
        "choices": [],
        "correct_answers": [],
        "starter_code": "let contains_duplicates (array : int array) : bool =\n    (* your code here *)",
        "test_code": "let () =\n    let result1 = contains_duplicates [|1; 2; 3; 4|];;\n    (* should return false *)\n    let result2 = contains_duplicates [|1; 2; 3; 3|];;\n    (* should return true *)\n    let result3 = contains_duplicates [|5; 5; 5; 5|];;\n    (* should return true *)\n    let result4 = contains_duplicates [|0|];;\n    (* should return false *)\n    Printf.printf \"Results: %b, %b, %b, %b\\n\" result1 result2 result3 result4; (* should print Results: false, true, true, false *)",
        "hint": "Consider using a Set to track elements that have already been seen while iterating through the array.",
        "explanation": "This function checks for duplicates by utilizing a Set to keep track of numbers that have already been encountered in the array. If a number is found that already exists in the Set, it returns true; otherwise, it continues until the end of the array. You might also want to explore how different data structures can optimize the searching process.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "ecbb3890-513f-4d58-acab-39c9edfde9e7",
        "chapter": "guided-tour",
        "section": "A Complete Program",
        "type": "multiple_choice",
        "question": "What does the `read_and_accumulate` function achieve in the given OCaml program context?",
        "choices": [
            "A) It accumulates the total sum of float numbers from standard input.",
            "B) It reads lines from a file and prints each line.",
            "C) It terminates the program after reading input.",
            "D) It converts string inputs directly into integers."
        ],
        "correct_answers": [
            0
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "The `read_and_accumulate` function reads lines from standard input, converts them to floats, and accumulates their total sum. This recursive approach enables the program to process an unknown number of float inputs until the end of input is reached.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "d30e6c12-8eca-467f-a67d-736e44ed15b9",
        "chapter": "guided-tour",
        "section": "A Complete Program",
        "type": "multiple_choice",
        "question": "Which library is required to use the `printf` function for formatted printing in OCaml?",
        "choices": [
            "A) Core",
            "B) Base",
            "C) Stdio",
            "D) InputOutput"
        ],
        "correct_answers": [
            2
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "The `printf` function is part of the Stdio library in OCaml, which provides input and output functionalities. Understanding library dependencies is crucial for successfully compiling and executing OCaml programs.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "8a771561-25f2-4c16-b224-1d469fcd1034",
        "chapter": "guided-tour",
        "section": "A Complete Program",
        "type": "programming",
        "question": "Implement a function to read and return the average of a list of floats received from standard input until EOF. Handle potential conversion errors gracefully.",
        "choices": [],
        "correct_answers": [],
        "starter_code": "let rec read_and_average accum count =\n  let line = In_channel.input_line In_channel.stdin in\n  match line with\n  | None -> if count = 0 then 0.0 else accum /. Float.of_int count\n  | Some x -> \n      let value = Float.of_string x in\n      read_and_average (accum +. value) (count + 1)",
        "test_code": "let () =\n  printf \"Average: %F\\n\" (read_and_average 0.0 0);; (* Input: 1, 2, 3 returns Average: 2.000000 *)\nlet () =\n  printf \"Average: %F\\n\" (read_and_average 0.0 0);; (* Input: 4.5, 5.5 returns Average: 5.000000 *)\n",
        "hint": "Use Tail Recursion to ensure efficient memory use by maintaining the accumulation of both the sum and count of inputs, returning a float that represents the average.",
        "explanation": "To solve this question, you will need to use recursion to read an indefinite number of lines. On each line read, convert the input to a float, then update the accumulated sum and count. When reaching the end of input (EOF), divide the accumulated sum by the count to calculate the average. You might find it useful to look into exception handling in OCaml for safely dealing with invalid float conversions.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "5202b4fb-2e73-457d-b027-a12847902ceb",
        "chapter": "guided-tour",
        "section": "Compiling and Running",
        "type": "multiple_choice",
        "question": "What is the purpose of the 'dune-project' file in an OCaml project?",
        "choices": [
            "A) It specifies the rules for building libraries.",
            "B) It dictates how to run the executable.",
            "C) It defines the project's root directory and settings.",
            "D) It contains all the source code for the project."
        ],
        "correct_answers": [
            2
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "The 'dune-project' file is used to specify the project's root directory and settings, including its name and version. Understanding the build system is crucial for managing OCaml projects effectively.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "b76b51b8-d23c-4594-bacd-9a174535f86a",
        "chapter": "guided-tour",
        "section": "Compiling and Running",
        "type": "multiple_choice",
        "question": "Which command is used to build an OCaml executable with dune?",
        "choices": [
            "A) dune run",
            "B) dune build sum",
            "C) dune compile sum.exe",
            "D) dune execute sum"
        ],
        "correct_answers": [
            1
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "The command 'dune build sum' is used to build the specified executable, where 'sum' is the name of the target. This command will compile the source code into an executable file.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "e4eaf14b-170b-489a-be3e-af0dfe53a646",
        "chapter": "guided-tour",
        "section": "Compiling and Running",
        "type": "programming",
        "question": "Write a function in OCaml that reads numbers from the command line until the end-of-file signal (Ctrl-D) is sent, sums these numbers, and prints the total to standard output.",
        "choices": [],
        "correct_answers": [],
        "starter_code": "let sum_from_input () =\n    (* your code here *)",
        "test_code": "let () = \n    sum_from_input ();; (* enter numbers such as 1, 2, 3 and then Ctrl-D, it should print \"Total: 6\" *)",
        "hint": "Use the 'In_channel' module to read input from standard input, and 'List.fold' to accumulate the sum of numbers.",
        "explanation": "This function will need to handle I/O operations and may require error handling for non-numeric input. After you implement it, consider exploring OCaml's 'Printf' for formatted output.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "3fe94d65-29dd-44bc-bf68-4e43d002d20e",
        "chapter": "guided-tour",
        "section": "Where to Go from Here",
        "type": "multiple_choice",
        "question": "What is one key takeaway from the 'Where to Go from Here' section of the Real World OCaml textbook?",
        "choices": [
            "A) There are many features and details yet to be covered",
            "B) OCaml lacks practical applications",
            "C) The book only covers basic syntax",
            "D) OCaml is similar to Python in every way"
        ],
        "correct_answers": [
            0
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "The correct answer is A) There are many features and details yet to be covered. This reflects the book's intent to provide ongoing learning opportunities in OCaml programming.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "0f2b2df7-fd0c-45e0-a2d7-a6a06d26ba27",
        "chapter": "guided-tour",
        "section": "Where to Go from Here",
        "type": "multiple_choice",
        "question": "Which of the following best describes the goal of the Real World OCaml textbook?",
        "choices": [
            "A) To provide a complete reference of OCaml",
            "B) To introduce OCaml in a practical and applied manner",
            "C) To compare OCaml with other programming languages",
            "D) To teach functional programming without specifics"
        ],
        "correct_answers": [
            1
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "The correct answer is B) To introduce OCaml in a practical and applied manner. The book positions itself as a guide for developers to effectively use OCaml in real-world scenarios.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "3ca537e8-2f65-47ff-b5cd-62499927ab4e",
        "chapter": "guided-tour",
        "section": "Where to Go from Here",
        "type": "programming",
        "question": "Implement a function that calculates the Fibonacci sequence up to a given number n, returning a list of Fibonacci numbers. Optimize your implementation for efficiency.",
        "choices": [],
        "correct_answers": [],
        "starter_code": "let fibonacci n = \n    (* your code here *) \n    [] \n",
        "test_code": "let () = \n    fibonacci 0;; (* should return [] *) \n    fibonacci 1;; (* should return [0] *) \n    fibonacci 2;; (* should return [0; 1; 1] *) \n    fibonacci 5;; (* should return [0; 1; 1; 2; 3] *) \n    fibonacci 10;; (* should return [0; 1; 1; 2; 3; 5; 8] *)",
        "hint": "Consider using a helper function to carry the current state, keeping track of both the previous and current Fibonacci numbers.",
        "explanation": "This problem tests not only your recursive implementation skills but also your ability to optimize for performance. An iterative approach or memoization could yield the best efficiency, especially for larger 'n'. You could explore how tail recursion or sequence breaking could help in this case.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "9acad14c-f7ea-476a-a776-b1073d2589e9",
        "chapter": "imperative-programming",
        "section": "Example: Imperative Dictionaries",
        "type": "multiple_choice",
        "question": "What is the primary purpose of the `iter` function in the dictionary implementation?",
        "choices": [
            "A) To create a new dictionary",
            "B) To filter out keys from the dictionary",
            "C) To iterate over each key/value pair and apply a function on them",
            "D) To find a key in the dictionary"
        ],
        "correct_answers": [
            2
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "Look for the definition of iter in the dictionary implementation.",
        "explanation": "The `iter` function is designed to traverse all entries in the dictionary and apply a function to each key/value pair. This allows you to perform actions on each entry without returning values. It's a common pattern in imperative programming.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "10e4597e-bb6c-4065-8857-25f684d7933e",
        "chapter": "imperative-programming",
        "section": "Example: Imperative Dictionaries",
        "type": "multiple_choice",
        "question": "What does the `bucket_has_key` function check in the dictionary?",
        "choices": [
            "A) Whether a given key exists in the dictionary",
            "B) Whether a specific bucket is empty",
            "C) The hash value of a key",
            "D) The length of the dictionary"
        ],
        "correct_answers": [
            0
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "Focus on the function's definition and its purpose within the add/remove operations.",
        "explanation": "The `bucket_has_key` function checks if a specific key is present in a particular bucket of the dictionary. This is important for determining whether to update the length of the dictionary and ensure no duplicate keys exist.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "f094d44f-a196-46a8-9328-a11ed159c502",
        "chapter": "imperative-programming",
        "section": "Example: Imperative Dictionaries",
        "type": "programming",
        "question": "Implement a function `create_dict` that initializes a dictionary with a given hash function and equality function. Implement the following functionalities as part of the dictionary: creating it, adding key-value pairs, finding values by keys, and iterating over entries in the dictionary.",
        "choices": [],
        "correct_answers": [],
        "starter_code": "open Base\n\ntype ('a, 'b) t = { mutable length : int; buckets : ('a * 'b) list array; hash : 'a -> int; equal : 'a -> 'a -> bool }\n\nlet create ~hash ~equal = \n  { length = 0; buckets = Array.create ~len:17 []; hash; equal }\n\nlet add t ~key ~data = \n  (* your implementation here *) \n\nlet find t key = \n  (* your implementation here *) \n\nlet iter t ~f = \n  (* your implementation here *) \n",
        "test_code": "let my_dict = create ~hash:Int.hash ~equal:Int.equal;;\n\nadd my_dict ~key:1 ~data:\"one\";;\nadd my_dict ~key:2 ~data:\"two\";;\nadd my_dict ~key:2 ~data:\"TWO\";; (* overwrites the first entry *)\n\nlet value_1 = find my_dict 1;; (* should return Some \"one\" *)\nlet value_2 = find my_dict 2;; (* should return Some \"TWO\" *)\n\niter my_dict ~f:(fun ~key ~data ->\n  printf \"Key: %d, Value: %s\\n\" key data) (* should print the pairs in the dictionary *)",
        "hint": "Remember to handle the mutable state carefully, especially when overwriting an existing key. Use the `equal` function to check for key equality.",
        "explanation": "The implementation takes into account the constructor for a dictionary and provides functionalities that allow for mutability while maintaining key uniqueness. It\u2019s a key example of managing state in OCaml, a functional programming language.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "9308b2f2-0bce-4f48-a1d1-7de91d77a16a",
        "chapter": "imperative-programming",
        "section": "Primitive Mutable Data",
        "type": "multiple_choice",
        "question": "What is the primary purpose of the `Bytes` type in OCaml?",
        "choices": [
            "A) To create immutable strings",
            "B) To create mutable arrays of bytes",
            "C) To optimize string concatenation",
            "D) To interact with C libraries"
        ],
        "correct_answers": [
            1
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "The `Bytes` type is specifically designed to create mutable byte arrays, providing a space-efficient alternative to mutable character arrays or strings. This allows for modification of byte values within the array.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "fca28094-c277-49ab-bc53-413804aa0842",
        "chapter": "imperative-programming",
        "section": "Primitive Mutable Data",
        "type": "multiple_choice",
        "question": "How do you define a mutable record field in OCaml?",
        "choices": [
            "A) By using the record syntax only",
            "B) By using the `mutable` keyword in the record definition",
            "C) By using the `ref` type for each field",
            "D) By marking the entire record as mutable"
        ],
        "correct_answers": [
            1
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "In OCaml, you define a mutable record field by using the `mutable` keyword in the record definition, which allows the field to be changed after the record is created.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "a90b176f-883a-43dc-8f38-d895c452b208",
        "chapter": "imperative-programming",
        "section": "Primitive Mutable Data",
        "type": "programming",
        "question": "Implement a function `increment_all` that takes a mutable array of integers and increments each element by a given integer value. Return the modified array.",
        "choices": [],
        "correct_answers": [],
        "starter_code": "let increment_all arr inc_value = \n    (* your code here *)",
        "test_code": "let arr = [|1; 2; 3|];;\nincrement_all arr 5;; (* should return [|6; 7; 8| *)\nlet arr2 = [|0; -1; 2|];;\nincrement_all arr2 3;; (* should return [|3; 2; 5| *)",
        "hint": "Use a loop to iterate over the indices of the array and use the `Array.set` function to assign the new values.",
        "explanation": "Implementing the `increment_all` function requires a good understanding of mutable arrays and how to modify their contents. The key here is to use a loop for iteration, which allows you to access each element by index and modify it.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "2765dc6d-40cf-41e8-9ce1-b3c1a582f9a3",
        "chapter": "imperative-programming",
        "section": "Array-Like Data",
        "type": "multiple_choice",
        "question": "What happens if you access an out-of-bounds index in an OCaml array?",
        "choices": [
            "A) Returns None",
            "B) Throws an exception",
            "C) Returns a default value",
            "D) Returns a negative index"
        ],
        "correct_answers": [
            1
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "Accessing an out-of-bounds index in an OCaml array throws an exception, which is important to handle when writing robust code. This behavior differentiates OCaml arrays from some other languages that might return a special value instead.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "a4df8367-e182-4a04-ac37-8ce1c0f7d593",
        "chapter": "imperative-programming",
        "section": "Array-Like Data",
        "type": "multiple_choice",
        "question": "Which of the following correctly describes the difference between strings and byte arrays in OCaml?",
        "choices": [
            "A) Strings are mutable, while byte arrays are immutable",
            "B) Byte arrays are used for textual data, while strings are for binary data",
            "C) Strings are immutable and space-efficient, while byte arrays are mutable and less space-efficient",
            "D) Both are mutable but require different syntax to manipulate"
        ],
        "correct_answers": [
            2
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "Strings in OCaml are indeed immutable and more space-efficient compared to byte arrays, which can be manipulated but are less space-efficient. This difference is crucial for understanding how to handle text and binary data in OCaml.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "eef4017f-13fc-4d36-96ec-77d7f73c650d",
        "chapter": "imperative-programming",
        "section": "Array-Like Data",
        "type": "programming",
        "question": "Implement a function that takes an array of integers and returns a new array that only contains the even integers from the original array. The output array should maintain the order of even numbers as they appear in the input array. Make sure to handle an empty input array properly by returning an empty array.",
        "choices": [],
        "correct_answers": [],
        "starter_code": "let filter_even (arr : int array) : int array =\n    (* your code here *)",
        "test_code": "(* Test for an array with mixed integers *)\nlet arr1 = filter_even [|1; 2; 3; 4; 5; 6|];; (* should return [|2; 4; 6|] *)\n(* Test for an array with no even integers *)\nlet arr2 = filter_even [|1; 3; 5|];; (* should return [||] *)\n(* Test for an empty array *)\nlet arr3 = filter_even [||];; (* should return [||] *)",
        "hint": "Consider using a dynamic array or list during the filtering process, and then convert it back to an array at the end. You might find List.filter helpful for this process.",
        "explanation": "In this implementation, you'll need to iterate through the original array, checking each element to see if it's even (using the modulo operator). The hint suggests starting with a list since OCaml's lists are easier to build dynamically compared to arrays, which have a fixed size. After filtering the even numbers, you can convert the resulting list back to an array using Array.of_list, providing a complete and efficient solution.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "18de8705-845c-43c5-b9dc-62b115402052",
        "chapter": "imperative-programming",
        "section": "Mutable Record and Object Fields and Ref Cells",
        "type": "multiple_choice",
        "question": "What is the purpose of the `ref` type in OCaml?",
        "choices": [
            "A) To create a mutable reference cell",
            "B) To create immutable data types",
            "C) To define constants",
            "D) To implement functional programming paradigms"
        ],
        "correct_answers": [
            0
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "The `ref` type is used to create a mutable reference cell that allows you to store a value that can be changed later. This is important because OCaml's defaults are immutable, and `ref` provides a way to have mutable state. Understanding how `ref` works can lead to interesting explorations of state management in functional programming.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "1ed3b5de-e5d0-44cb-a8cc-65f8f4e03d67",
        "chapter": "imperative-programming",
        "section": "Mutable Record and Object Fields and Ref Cells",
        "type": "multiple_choice",
        "question": "Which operator is used to modify the contents of a reference cell in OCaml?",
        "choices": [
            "A) =",
            "B) <-",
            "C) :=",
            "D) !"
        ],
        "correct_answers": [
            2
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "The operator := is specifically designed to change the contents of a reference cell after it has been created. This emphasizes the distinction between accessing the contents (using !) and modifying it (using :=). This highlights how OCaml allows mutable state while maintaining a primarily functional approach.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "e5a3e65d-bdb1-4d59-b4ab-7147c616e782",
        "chapter": "imperative-programming",
        "section": "Mutable Record and Object Fields and Ref Cells",
        "type": "programming",
        "question": "Implement a function that accepts a list of integer reference cells and returns the sum of the values they reference. Use mutable record fields or ref cells as needed.",
        "choices": [],
        "correct_answers": [],
        "starter_code": "let sum_ref_cells lst =\n    (* your code here *)\n",
        "test_code": "let rc1 = ref 10;; (* 10 *)\nlet rc2 = ref 20;; (* 20 *)\nlet rc3 = ref 30;; (* 30 *)\nlet total = sum_ref_cells [rc1; rc2; rc3];; (* should return 60 *)\n\nlet rc4 = ref 5;; (* 5 *)\nlet rc5 = ref 10;; (* 10 *)\nlet total2 = sum_ref_cells [rc4; rc5];; (* should return 15 *)\n",
        "hint": "You can use List.fold_right to accumulate the sum, extracting values from each reference cell using the dereference operator (!). You\u2019ll need to manage the function signature carefully to ensure it accepts the correct type.",
        "explanation": "The challenge here lies in correctly managing mutable fields with references. By extracting values from each reference cell using the dereference operator, we can combine the mutable aspect of references with OCaml's functional paradigms. This exercise can lead to discovering more about how OCaml handles mutable state and its interactions with functional programming.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "8cf78cd0-39ce-4ab4-bb80-db0aef5e1f45",
        "chapter": "imperative-programming",
        "section": "Foreign Functions",
        "type": "multiple_choice",
        "question": "What is the purpose of OCaml's Foreign Function Interface (FFI)?",
        "choices": [
            "A) To implement multiprocessing in OCaml",
            "B) To allow OCaml to call functions in external libraries",
            "C) To define new types in OCaml",
            "D) To enhance the syntax of OCaml"
        ],
        "correct_answers": [
            1
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "The FFI in OCaml is used to call functions from external libraries, which makes it possible to utilize existing C libraries and system calls directly in OCaml programs. This provides a bridge between OCaml and the vast ecosystem of C libraries available.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "4c244cd9-6680-4027-a554-a65aa6ec3577",
        "chapter": "imperative-programming",
        "section": "Foreign Functions",
        "type": "multiple_choice",
        "question": "Which of the following is NOT a common use of OCaml's FFI?",
        "choices": [
            "A) Accessing system-level operations like clock or write",
            "B) Using OCaml for front-end web development",
            "C) Incorporating existing C libraries into OCaml applications",
            "D) Implementing prompt and low-level operations using external APIs"
        ],
        "correct_answers": [
            1
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "While the FFI allows OCaml to call functions in C libraries and perform system calls, it is not typically associated with front-end web development, which usually involves languages like JavaScript. The other options are common uses of the FFI.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "70986eb9-c8d7-49da-925f-fbe13dfb7d29",
        "chapter": "imperative-programming",
        "section": "Foreign Functions",
        "type": "programming",
        "question": "Implement an OCaml function that retrieves the current system time using the OCaml Foreign Function Interface (FFI) to interact with the C library.",
        "choices": [],
        "correct_answers": [],
        "starter_code": "(* Define external function using FFI to call clock_gettime from C *)\nexternal clock_gettime : unit -> float = \"clock_gettime\" (* Assuming the necessary C function is implemented *)\n\nlet get_current_time () = \n    (* your code here *)",
        "test_code": "let time1 = get_current_time();; (* should return the current time in seconds as a float *)\nlet time2 = get_current_time();; (* should be greater than time1 *)",
        "hint": "Make sure to declare the external function and handle any units or conversions if necessary. You may need to research the specific C types that OCaml's FFI can interface with.",
        "explanation": "This problem requires knowledge of both OCaml and C, especially how to appropriately call external functions. The `clock_gettime` function from the C library is a typical example of a system call that can be accessed. Users may also want to explore how OCaml handles multi-threading when calling C functions.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "387704ac-0bf0-4eba-9281-7abd61cc1bb3",
        "chapter": "imperative-programming",
        "section": "For and While Loops",
        "type": "multiple_choice",
        "question": "What does the 'for' loop in OCaml define regarding the loop variable?",
        "choices": [
            "A) The loop variable can be modified within the loop",
            "B) The loop variable is mutable but scoped globally",
            "C) The loop variable is immutable and scoped locally",
            "D) The loop variable is defined globally and mutable"
        ],
        "correct_answers": [
            2
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "The correct answer is C. In OCaml's 'for' loop, the loop variable is immutable, meaning it cannot be reassigned, and it is also scoped locally to the loop. This prevents any changes made to the loop variable from affecting other parts of the program.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "d84af6e1-214f-4138-82bf-a44494aeb66f",
        "chapter": "imperative-programming",
        "section": "For and While Loops",
        "type": "multiple_choice",
        "question": "Which function is utilized in the example to reverse the elements of an array in OCaml?",
        "choices": [
            "A) List.rev",
            "B) Array.reverse",
            "C) rev_inplace",
            "D) Array.flip"
        ],
        "correct_answers": [
            2
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "The correct answer is C, rev_inplace. This is a user-defined function that reverses an array in place using a while loop. It swaps elements until the two indices meet.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "89ae7719-7c60-4d3b-aabd-6be7439bcc72",
        "chapter": "imperative-programming",
        "section": "For and While Loops",
        "type": "programming",
        "question": "Implement a function that counts the number of even numbers in an array using a while loop. The function should iterate through the array and return the count of even numbers encountered.",
        "choices": [],
        "correct_answers": [],
        "starter_code": "let count_evens arr =\n    (* your code here *)\n    ();",
        "test_code": "let nums1 = [|1; 2; 3; 4; 5|];;\nlet nums2 = [|10; 21; 32; 43; 54|];;\nlet nums3 = [|0; -2; -4; 8; -16|];;\n\nlet evens1 = count_evens nums1;; (* should return 2 *)\nlet evens2 = count_evens nums2;; (* should return 3 *)\nlet evens3 = count_evens nums3;; (* should return 5 *)",
        "hint": "Think about using a while loop with a counter to keep track of even numbers as you iterate over the array.",
        "explanation": "The count_evens function should initialize a counter to zero and use a while loop to traverse the array. For each element, check if it's even using the modulo operator. If it is even, increment the counter. Finally, return the counter at the end of the loop.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "08b56d68-e431-47ce-b36c-91b1debb49bb",
        "chapter": "imperative-programming",
        "section": "Example: Doubly Linked Lists",
        "type": "multiple_choice",
        "question": "What functionality is provided by the function `insert_first` in the doubly linked list implementation?",
        "choices": [
            "A) Inserts an element at the end of the list",
            "B) Removes the first element from the list",
            "C) Inserts an element at the front of the list",
            "D) Searches for an element in the list"
        ],
        "correct_answers": [
            2
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "The `insert_first` function adds a new element at the beginning of the doubly linked list. This is accomplished by creating a new element and adjusting the pointers of the existing list elements accordingly.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "eff3049c-34de-4b15-8662-4cd80f2f0eb1",
        "chapter": "imperative-programming",
        "section": "Example: Doubly Linked Lists",
        "type": "multiple_choice",
        "question": "What does the `iter` function do in the context of doubly linked lists?",
        "choices": [
            "A) Iterates through the list and accumulates a result",
            "B) Iterates through the list and applies a function to each element",
            "C) Finds the first element matching a condition",
            "D) Clears all elements in the list"
        ],
        "correct_answers": [
            1
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "The `iter` function traverses each element of the doubly linked list, applying a provided function to each element. This allows side-effects or operations to be performed on every value in the list.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "effaf27f-a7b1-4bf8-bcc0-f444c2b608c0",
        "chapter": "imperative-programming",
        "section": "Example: Doubly Linked Lists",
        "type": "programming",
        "question": "Implement a function `remove_duplicates` that removes duplicate values from a doubly linked list while maintaining the original order of elements. The function should return a new list with duplicates removed, and utilize the existing operations from the doubly linked list implementation.",
        "choices": [],
        "correct_answers": [],
        "starter_code": "type 'a element =\n  { value : 'a;\n    mutable next : 'a element option;\n    mutable prev : 'a element option; }\n\ntype 'a t = 'a element option ref\n\nlet remove_duplicates lst =\n  (* your code here *)",
        "test_code": "let test_list = ref (Some { value = 1; next = None; prev = None });;\n(* General setup for the test list with duplicates: *)\nlet _ = insert_first test_list 2;(* list: 2, 1 *) \nlet _ = insert_first test_list 1;(* list: 1, 2, 1 *) \nlet _ = insert_first test_list 3;(* list: 3, 1, 2, 1 *) \nlet new_list = remove_duplicates test_list;; \n(* Expected: list with values 3, 1, 2 *) \nlet _ = iter new_list ~f:(fun v -> printf \"%d \\n\" v) ;; (* Visual inspection should reveal: 3, 1, 2 *)",
        "hint": "Keep track of seen elements using a set to efficiently check for duplicates. Modify the pointers of both previous and next elements accordingly as you traverse the list.",
        "explanation": "In this problem, you need to traverse the list while keeping track of seen values. When a duplicate is recognized, you should unlink that node by adjusting the adjacent nodes' pointers. Be cautious while handling the first and last elements as they require special attention.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "3dd4f36e-0cd5-4de8-b323-8b29c8665e67",
        "chapter": "imperative-programming",
        "section": "Modifying the List",
        "type": "multiple_choice",
        "question": "What is the primary purpose of the `insert_first` function in OCaml's list modification context?",
        "choices": [
            "A) To remove an element from the list",
            "B) To insert an element at the front of the list",
            "C) To find an element in the list",
            "D) To create a new list"
        ],
        "correct_answers": [
            1
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "The `insert_first` function is designed to insert a new element at the front of the list. It does so by creating a new node and linking it as the first element, thereby modifying the list structure.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "28ba054d-0208-4b50-895b-ade190d0d2cd",
        "chapter": "imperative-programming",
        "section": "Modifying the List",
        "type": "multiple_choice",
        "question": "Which of the following statements about the `remove` function is correct?",
        "choices": [
            "A) It only updates the previous pointer of the next element when removing an element.",
            "B) It sets the next and previous pointers of the removed element to None.",
            "C) It cannot handle cases where the list is empty.",
            "D) It uses a recursive approach to remove the element."
        ],
        "correct_answers": [
            1
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "The `remove` function sets the next and previous pointers of the removed element to `None` after removing it from the list, ensuring that the element no longer references any nodes.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "c62d01a5-f5e9-4198-9ff1-60c593e52a21",
        "chapter": "imperative-programming",
        "section": "Modifying the List",
        "type": "programming",
        "question": "Implement a function `insert_before` that takes an element and a value, and inserts a new element before the given element in the list. Consider handling edge cases such as inserting before the head or dealing with an empty list. Be careful to maintain the integrity of the list structure.",
        "choices": [],
        "correct_answers": [],
        "starter_code": "type 'a node = {mutable prev: 'a node option; mutable next: 'a node option; value: 'a};\ntype 'a t = 'a node option ref;\nlet insert_before (t: 'a t) (elt: 'a node) (value: 'a) =\n  let new_elt = { prev = elt.prev; next = Some elt; value } in\n  (match elt.prev with\n  | Some prev -> prev.next <- Some new_elt\n  | None -> t := Some new_elt);\n  elt.prev <- Some new_elt;",
        "test_code": "let my_list = ref None;;\ninserter := insert_first my_list 2;; (* Inserts 2 at the front *) \ninserter := insert_first my_list 3;; (* Inserts 3 at the front *)\ninsert_before my_list (Option.get !my_list) 5;; (* Inserts 5 before 3 *)\n(* Expected list: (5 -> 3 -> 2) *)\nlet _ =\n  match !my_list with\n  | Some x -> Printf.printf \"List first value: %d\" x.value\n  | None -> Printf.printf \"List is empty\";(* Should print 5 and the rest of the list's elements can be traversed similarly *)",
        "hint": "Make sure to properly update the `prev` and `next` pointers of the involved nodes when inserting. Consider special cases when the list is empty or when inserting before the first element.",
        "explanation": "The function should carefully handle all pointer adjustments to maintain list integrity. Look into how `insert_after` function works for an analogous structure that might help.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "0377588f-cfb9-4705-85a2-adf43dfbdb83",
        "chapter": "imperative-programming",
        "section": "Iteration Functions",
        "type": "multiple_choice",
        "question": "What is the purpose of the \u2018iter\u2019 function in the provided implementation of a linked list?",
        "choices": [
            "A) To return the first element of the list.",
            "B) To apply a given function to every element in the list.",
            "C) To create a new list from existing elements.",
            "D) To remove an element from the list."
        ],
        "correct_answers": [
            1
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "Look at how the function processes each element in sequence without returning a value.",
        "explanation": "The purpose of the \u2018iter\u2019 function is to apply a provided function to each element in the list (choice B). This function does not return a new list or any modified data; instead, it merely allows side effects based on the function provided.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "47913414-14e1-4657-92b6-506806ecc75a",
        "chapter": "imperative-programming",
        "section": "Iteration Functions",
        "type": "multiple_choice",
        "question": "In the function \u2018find_el\u2019, what does it return when no element satisfies the provided test function?",
        "choices": [
            "A) The first element of the list.",
            "B) None.",
            "C) An exception is thrown.",
            "D) The last element checked."
        ],
        "correct_answers": [
            1
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "Consider the base case of the recursive function and what should happen when no matches are found.",
        "explanation": "The \u2018find_el\u2019 function returns None when no element in the list satisfies the test function, indicated by the base case in its recursive implementation (choice B). This showcases how to safely handle the absence of a valid return value.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "96bf61ae-abcc-4d3d-90f7-a1b5ceacb385",
        "chapter": "imperative-programming",
        "section": "Iteration Functions",
        "type": "programming",
        "question": "Implement a function \u2018filter\u2019 that returns a new list containing all elements that satisfy a given predicate function applied to each element of the input list.",
        "choices": [],
        "correct_answers": [],
        "starter_code": "let filter lst ~f =\n  (* your code here *)",
        "test_code": "let result1 = filter [1; 2; 3; 4] ~f:(fun x -> x mod 2 = 0);; (* should return [2; 4] *)\nlet result2 = filter [\"apple\"; \"banana\"; \"cherry\"] ~f:(fun s -> String.length s > 5);; (* should return [\"banana\", \"cherry\"] *)\nlet result3 = filter [] ~f:(fun x -> x > 0);; (* should return [] *)",
        "hint": "Use recursion to traverse the list and apply the predicate function on each element. Make sure to collect matching elements into a new list during your traversal.",
        "explanation": "The \u2018filter\u2019 function combines elements that match a condition. You can think of it as a variation of the \u2018find_el\u2019 function, but instead of returning immediately on the first match, it collects all matches in a new list. This function also showcases recursion and list construction in OCaml. Explore more about recursion and list processing to enhance your understanding.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "9c73c751-19a5-41bc-a10e-7f2ada0ba76a",
        "chapter": "imperative-programming",
        "section": "Laziness and Other Benign Effects",
        "type": "multiple_choice",
        "question": "What is the key advantage of using lazy evaluation in OCaml?",
        "choices": [
            "A) It allows computation to be deferred until necessary.",
            "B) It guarantees side effects occur before any computation.",
            "C) It ensures all computations are completed in a fixed order.",
            "D) It eliminates the need for recursive functions."
        ],
        "correct_answers": [
            0
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "The correct answer is A. Lazy evaluation defers computation until the result is actually required, which can improve performance by avoiding unnecessary calculations.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "7238ca4f-da16-4a3b-8e34-a2ad1560932d",
        "chapter": "imperative-programming",
        "section": "Laziness and Other Benign Effects",
        "type": "multiple_choice",
        "question": "In the implementation of a memoized Fibonacci function, which of the following statements is true?",
        "choices": [
            "A) The memoization table is cleared after every function call.",
            "B) A memoized function can cause memory leaks if it retains references.",
            "C) Memoization enhances the performance of all recursive functions unconditionally.",
            "D) The memoization key can only be a single type of integer."
        ],
        "correct_answers": [
            1
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "The correct answer is B. Since the memoization table holds results of previous computations, it can lead to memory leaks if the memoized function is retained indefinitely.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "190d6311-d9a0-4218-a755-1f5880dfe684",
        "chapter": "imperative-programming",
        "section": "Laziness and Other Benign Effects",
        "type": "programming",
        "question": "Implement a memoized version of the edit distance function that efficiently calculates the number of operations required to convert one string into another. Use a hash table to store previously computed results.",
        "choices": [],
        "correct_answers": [],
        "starter_code": "let edit_distance = memo_rec (module String_pair)\n  (fun edit_distance (s,t) ->\n     match String.length s, String.length t with\n     | (0,x) | (x,0) -> x\n     | (len_s,len_t) ->\n       let s' = String.drop_suffix s 1 in\n       let t' = String.drop_suffix t 1 in\n       let cost_to_drop_both =\n         if Char.(=) s.[len_s - 1] t.[len_t - 1] then 0 else 1\n       in\n       List.reduce_exn ~f:Int.min\n         [ edit_distance (s',t ) + 1\n         ; edit_distance (s ,t') + 1\n         ; edit_distance (s',t') + cost_to_drop_both\n       ]);;",
        "test_code": "(* Test cases for the memoized edit distance function *)\nlet result1 = edit_distance (\"OCaml\", \"ocaml\");; (* expected output: 2 *)\nlet result2 = edit_distance (\"kitten\", \"sitting\");; (* expected output: 3 *)\nlet result3 = edit_distance (\"flaw\", \"lawn\");; (* expected output: 2 *)\nlet result4 = edit_distance (\"\", \"nonempty\");; (* expected output: 9 *)\nlet result5 = edit_distance (\"similar\", \"similar\");; (* expected output: 0 *)",
        "hint": "Consider how to use a pair of strings as a key for the memoization. You may want to use a module for string pairs that supports hashing.",
        "explanation": "This implementation memoizes the results of edit distance to avoid redundant calculations. The performance boost comes from storing intermediate results, greatly reducing the number of computations needed for larger strings.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "5ab3d593-36be-4698-810e-db2408de2c69",
        "chapter": "imperative-programming",
        "section": "Memoization and Dynamic Programming",
        "type": "multiple_choice",
        "question": "What is the purpose of the `memoize` function defined in the text?",
        "choices": [
            "A) To create a synchronous function",
            "B) To cache previously computed results of a function",
            "C) To optimize memory usage when computing a function",
            "D) To automatically parallelize function calls"
        ],
        "correct_answers": [
            1
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "The `memoize` function is designed to cache results of function calls so that repeated calls with the same arguments can return results immediately without recomputation. This is particularly useful for functions that are expensive to evaluate. It is a foundational concept in optimization techniques like dynamic programming.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "729a00d2-0d79-49a9-8c51-90af57353166",
        "chapter": "imperative-programming",
        "section": "Memoization and Dynamic Programming",
        "type": "multiple_choice",
        "question": "How does the `fib` function benefit from memoization?",
        "choices": [
            "A) It reduces space complexity",
            "B) It eliminates redundant calculations during function calls",
            "C) It makes the function recursive",
            "D) It allows for infinite recursion"
        ],
        "correct_answers": [
            1
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "By memoizing the `fib` function, we avoid repeating calculations for the same Fibonacci number. This effectively changes the time complexity from exponential to linear, making it much more efficient.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "1bd553c0-023c-4479-a27b-530d20d49506",
        "chapter": "imperative-programming",
        "section": "Memoization and Dynamic Programming",
        "type": "programming",
        "question": "Implement a memoized version of the `edit_distance` function that takes a pair of strings as input and calculates the Levenshtein distance. Use the Base library's Hashtbl for storage.",
        "choices": [],
        "correct_answers": [],
        "starter_code": "(* Define the module for string pairs with hashable types *)\ntype string_pair = string * string\nmodule String_pair = struct\n  type t = string_pair [@@deriving sexp_of, hash, compare]\nend;;\n\n(* Memoized edit distance function *)\nlet edit_distance =  \n  memo_rec (module String_pair)\n    (fun edit_distance (s, t) ->\n       match String.length s, String.length t with\n       | (0,x) | (x,0) -> x\n       | (len_s,len_t) ->\n         let s' = String.drop_suffix s 1 in\n         let t' = String.drop_suffix t 1 in\n         let cost_to_drop_both =\n           if Char.(=) s.[len_s - 1] t.[len_t - 1] then 0 else 1\n         in\n         List.reduce_exn ~f:Int.min\n           [ edit_distance (s', t) + 1\n           ; edit_distance (s, t') + 1\n           ; edit_distance (s', t') + cost_to_drop_both\n           ]\n    );;\n",
        "test_code": "let () =\n  let result1 = edit_distance (\"kitten\", \"sitting\") in\n  printf \"Edit distance between 'kitten' and 'sitting' is %d\\n\" result1;\n  (* Expected output: 3 *)\n\n  let result2 = edit_distance (\"flaw\", \"lawn\") in\n  printf \"Edit distance between 'flaw' and 'lawn' is %d\\n\" result2;\n  (* Expected output: 2 *)\n\n  let result3 = edit_distance (\"intention\", \"execution\") in\n  printf \"Edit distance between 'intention' and 'execution' is %d\\n\" result3;\n  (* Expected output: 5 *)\n",
        "hint": "Ensure that you leverage Base's Hashtbl to store already computed distances. The implementation should follow the recursive structure as defined but adjusted for pair inputs. Focus on making the recursive calls use the memoized version.",
        "explanation": "The `edit_distance` function calculates how many edits (insertions, deletions, substitutions) are required to convert one string into another. The memoization significantly optimizes performance by storing results of previously computed distances for specific pairs of strings, thereby avoiding repeated calculations.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "2505e058-defb-4f40-b93f-7d16b9a15419",
        "chapter": "imperative-programming",
        "section": "Input and Output",
        "type": "multiple_choice",
        "question": "What is the purpose of the Out_channel.flush function in OCaml?",
        "choices": [
            "A) It clears the output buffer immediately.",
            "B) It writes all buffered output to the output channel.",
            "C) It closes the output channel entirely.",
            "D) It formats the output before printing."
        ],
        "correct_answers": [
            1
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "The Out_channel.flush function is used to ensure that all buffered data is actually written to the output channel. Buffers are used to improve efficiency by minimizing the number of system calls, and flushing the output makes sure all the data is sent to the destination.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "bb6b779e-f177-4480-a83e-f86653d64971",
        "chapter": "imperative-programming",
        "section": "Input and Output",
        "type": "multiple_choice",
        "question": "Which of the following statements about OCaml's printf function is TRUE?",
        "choices": [
            "A) It does not type-check the formats provided at compile-time.",
            "B) It allows format strings to be regular strings without annotations.",
            "C) It provides formatted output that is type-safe.",
            "D) It requires all format strings to be passed as non-literal strings."
        ],
        "correct_answers": [
            2
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "The printf function in OCaml is type-safe, meaning it checks the types of the values being printed against the format string at compile time, ensuring that the types match.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "85043967-83ce-4972-872e-23e35d1e8221",
        "chapter": "imperative-programming",
        "section": "Input and Output",
        "type": "programming",
        "question": "Implement a function that reads a list of integers from a file and returns their product. Ensure that your function safely handles file opening and closing, even if an error occurs while reading the integers. Use In_channel.fold_lines to read the file line by line to optimize memory usage.",
        "choices": [],
        "correct_answers": [],
        "starter_code": "let product_file filename = \n  (* your code here *)",
        "test_code": "(* Sample Usage: *)\n(* Assuming 'numbers.txt' contains:\n   2\n   3\n   4\n   *)\nlet prod = product_file \"numbers.txt\";; (* should return 24 *)\n\n(* Testing with a non-existent file *)\n(* let prod2 = product_file \"nonexistent.txt\";; *)\n(* This should handle the exception gracefully without leaking resources. *)",
        "hint": "Use In_channel.with_file to manage the file processing safely, and use In_channel.fold_lines to read the file line by line. Remember to handle potential exceptions that could arise from converting lines to integers.",
        "explanation": "This problem involves working with file I/O and ensuring resources are managed safely. The use of In_channel.with_file helps in automatic cleanup of resources, and In_channel.fold_lines optimizes memory usage by processing the file one line at a time.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "e09189f7-3e83-4854-a92b-3bbcf209dc84",
        "chapter": "imperative-programming",
        "section": "Terminal I/O",
        "type": "multiple_choice",
        "question": "What is the purpose of the Out_channel.flush function in OCaml's buffered I/O?",
        "choices": [
            "A) It clears the buffer of standard input",
            "B) It immediately writes to the output channel, ensuring all buffered data is sent",
            "C) It reads data from an input channel",
            "D) It initializes an output channel"
        ],
        "correct_answers": [
            1
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "Look for the definition and explanation of Out_channel.flush in the I/O library.",
        "explanation": "Out_channel.flush is used to ensure that all buffered data written to an output channel is immediately sent to the output. This is important in cases where you want to ensure that the user can see output at a specific point in time, rather than waiting for the buffer to fill up. This function is especially useful for interactive applications.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "b04bff99-3ee4-4e0c-973d-4b09d7d23991",
        "chapter": "imperative-programming",
        "section": "Terminal I/O",
        "type": "multiple_choice",
        "question": "In OCaml's I/O operations, which of the following default channels corresponds to standard error messages?",
        "choices": [
            "A) stdin",
            "B) stdout",
            "C) stderr",
            "D) Both stdin and stdout"
        ],
        "correct_answers": [
            2
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "Consider the standard file descriptors used in UNIX systems and their purpose.",
        "explanation": "The stderr channel is designated for error messages, allowing them to be separated from standard output (stdout), which is intended for regular output. This separation is useful for directing errors to different locations than standard output streams.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "637ed617-daa3-488a-a483-84f27f8f4dcc",
        "chapter": "imperative-programming",
        "section": "Terminal I/O",
        "type": "programming",
        "question": "Implement a function that reads user input from the terminal and capitalizes each word in the input string. The program should handle input until EOF is reached. Additionally, it should display the transformed string back to the user.",
        "choices": [],
        "correct_answers": [],
        "starter_code": "let capitalize_words input = \n  let capitalize_word word = String.capitalize_ascii word in\n  String.split ~on:' ' input\n  |> List.map ~f:capitalize_word\n  |> String.concat ~sep:\" \";;\n\nlet () = \n  Out_channel.output_string stdout \"Please enter a sentence: \";\n  Out_channel.flush stdout;\n  let rec read_input acc = \n  match In_channel.input_line stdin with \n  | None -> acc \n  | Some line -> read_input (acc ^ line ^ \" \") in\n  let user_input = read_input \"\" in\nthe_string = capitalize_words user_input;\n  Out_channel.output_string stdout (the_string ^ \"\\n\");\n  Out_channel.flush stdout;",
        "test_code": "(* Expected Input: \"hello world\" *)\nlet () = \n  Out_channel.output_string stdout \"Test case: hello world\\n\";\n  let result = capitalize_words \"hello world\" in\n  Out_channel.output_string stdout (result ^ \"\\n\"); (* Expected Output: \"Hello World\" *)\n\n(* Test with another string *)\nlet () = \n  Out_channel.output_string stdout \"Test case: ocaml is great\\n\";\n  let result = capitalize_words \"ocaml is great\" in\n  Out_channel.output_string stdout (result ^ \"\\n\"); (* Expected Output: \"Ocaml Is Great\" *)",
        "hint": "Use String functions effectively to tokenize and capitalize words. Take care of input reading until EOF.",
        "explanation": "This problem requires understanding of string manipulation and handling inputs from the terminal. Capitalizing the first letter of each word involves splitting the string, processing each piece, and then joining them back together.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "9880088a-b0fd-47e7-9c94-13c81c62d458",
        "chapter": "imperative-programming",
        "section": "Formatted Output with printf",
        "type": "multiple_choice",
        "question": "Which of the following features distinguishes OCaml's `printf` from C's `printf`?",
        "choices": [
            "A) Variable argument list",
            "B) Type safety",
            "C) Format strings are always dynamic",
            "D) Supports more formatting options"
        ],
        "correct_answers": [
            1
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "OCaml's `printf` is type-safe, meaning the types of the arguments must match the types specified in the format string. This prevents runtime errors that can occur with C's `printf`, where type mismatches can lead to undefined behavior.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "71fcdabf-c582-4911-bd57-7bdf4c95206a",
        "chapter": "imperative-programming",
        "section": "Formatted Output with printf",
        "type": "multiple_choice",
        "question": "What happens if you try to pass an ordinary string instead of a format string to OCaml's `printf`?",
        "choices": [
            "A) It simply prints the string",
            "B) It results in a type error",
            "C) It prints the string with all values as placeholders",
            "D) It behaves like `fprintf` to a default file"
        ],
        "correct_answers": [
            1
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "In OCaml, passing an ordinary string to `printf` causes a type error because it expects a format string that specifies the types of the arguments provided. This is part of the language's type safety.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "45c3cb5b-5306-44f4-8b29-690e94e3fb97",
        "chapter": "imperative-programming",
        "section": "Formatted Output with printf",
        "type": "programming",
        "question": "Implement a function that takes a timezone string and prints the current time in that timezone using formatted output with `printf`. Handle cases where the timezone might not be valid, and provide appropriate error messages.",
        "choices": [],
        "correct_answers": [],
        "starter_code": "open Core\n\nlet print_current_time_in_timezone timezone =\n  match Time_unix.Zone.find timezone with\n  | None -> printf \"Error: Invalid timezone '%s'.\\n\" timezone\n  | Some zone ->\n      let time_string = Time.to_string_abs (Time.now ()) ~zone in\n      printf \"The current time in %s is %s.\\n\" (Time_unix.Zone.to_string zone) time_string;;",
        "test_code": "(* Test valid timezone *)\nprint_current_time_in_timezone \"America/New_York\";  (* Expected output: The current time in America/New_York is ... *)\n\n(* Test invalid timezone *)\nprint_current_time_in_timezone \"Invalid/Zone\"; (* Expected output: Error: Invalid timezone 'Invalid/Zone'. *)",
        "hint": "Use the `Time_unix.Zone.find` function to check if the timezone is valid. If valid, retrieve the current time and format the output accordingly.",
        "explanation": "The task requires using formatted output to display the current time for a provided timezone. Handling invalid inputs reinforces error handling and proper usage of the `printf` function for formatted strings.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "5aca40e3-1450-4293-817a-a2f6b9cd0796",
        "chapter": "imperative-programming",
        "section": "File I/O",
        "type": "multiple_choice",
        "question": "What does the `Exn.protect` function do in OCaml file handling?",
        "choices": [
            "A) It prevents exceptions from being thrown",
            "B) It ensures cleanup code runs even if an exception is raised",
            "C) It asserts that a file is open before using it",
            "D) It automatically closes files after usage"
        ],
        "correct_answers": [
            1
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "The `Exn.protect` function is used for exception handling in OCaml, ensuring that the cleanup code (in this case, closing a file) is executed even if an exception occurs during the file manipulation.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "173fed1b-7679-415f-aa46-b0e1958a5ce2",
        "chapter": "imperative-programming",
        "section": "File I/O",
        "type": "multiple_choice",
        "question": "Which of the following implementations of `sum_file` correctly avoids running out of file descriptors?",
        "choices": [
            "A) Using Exn.protect for cleanup",
            "B) Using In_channel.with_file for resource management",
            "C) Repeatedly calling sum_file in a loop",
            "D) Reading file content directly into a list"
        ],
        "correct_answers": [
            0,
            1
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "Both implementations A and B ensure proper handling of file descriptors. Using `Exn.protect` ensures the file closes on error, while `In_channel.with_file` automatically manages the file resource without requiring manual intervention.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "dfb94967-4642-4def-a521-66af2f439fc0",
        "chapter": "imperative-programming",
        "section": "File I/O",
        "type": "programming",
        "question": "Implement a function named `sum_file_lines` that reads a file line by line, converts each line to an integer, and returns the sum of these integers. Ensure that the function is efficient and does not load all lines into memory at once.",
        "choices": [],
        "correct_answers": [],
        "starter_code": "let sum_file_lines filename =\n    (* your code here *)",
        "test_code": "(* Test on a valid file *)\ncreate_number_file \"test_numbers.txt\" [1; 2; 3; 4; 5];;\nlet total = sum_file_lines \"test_numbers.txt\";; (* should return 15 *)\n(* Test on a file with negative and positive integers *)\ncreate_number_file \"mixed_numbers.txt\" [-1; 2; 3; -4; 5];;\nlet mixed_total = sum_file_lines \"mixed_numbers.txt\";; (* should return 5 *)\n(* Test on a large file *)\nlet large_sum = sum_file_lines \"large_numbers.txt\";; (* expected output if numbers are known *)",
        "hint": "Consider using In_channel.fold_lines to process the file efficiently, line by line.",
        "explanation": "The function `sum_file_lines` should utilize the `In_channel.fold_lines` method to handle large files without loading them entirely into memory, allowing you to process each line as it is read.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "582f9c29-1da0-46ba-bd46-2557bf4b4660",
        "chapter": "imperative-programming",
        "section": "Order of Evaluation",
        "type": "multiple_choice",
        "question": "What is the value of evaluating a list of lazily defined sine values with `List.exists` to check for negative results?",
        "choices": [
            "A) Always true since all values are positive",
            "B) Evaluation completes without computing all sine values",
            "C) The order of evaluation does not affect result",
            "D) All sine values must be computed before result can be determined"
        ],
        "correct_answers": [
            1
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "Consider the behaviour of lazy evaluation in combination with the `List.exists` function.",
        "explanation": "In a lazy evaluation context, expressions are only computed when their values are needed. In this case, because we are checking for negative values using `List.exists`, it will stop as soon as it finds the first negative result without requiring unnecessary computations for other values.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "780ee172-1eb4-424d-8794-f4c1c6546d26",
        "chapter": "imperative-programming",
        "section": "Order of Evaluation",
        "type": "multiple_choice",
        "question": "Why is understanding order of evaluation important in OCaml specifically in an imperative programming context?",
        "choices": [
            "A) It allows you to write faster code",
            "B) Side effects happen in an unpredictable order",
            "C) Implicitly evaluates values in parallel",
            "D) OCaml does not guarantee any evaluation order"
        ],
        "correct_answers": [
            1
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "Think about how side effects can change the state in imperative programming.",
        "explanation": "In imperative programming, side effects can lead to changes in program state, and if the order in which these side effects occur is not well understood, it can lead to unexpected results. Understanding this helps in reasoning about program behaviour.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "642d35ca-fdc6-4626-8235-2f84da0a4b38",
        "chapter": "imperative-programming",
        "section": "Order of Evaluation",
        "type": "programming",
        "question": "Implement a function `lazy_sin_negatives` that takes a list of angles and returns true if any angle has a negative sine value, using lazy evaluation to avoid unnecessary computations.",
        "choices": [],
        "correct_answers": [],
        "starter_code": "let lazy_sin_negatives angles =\n    (* your code here *)",
        "test_code": "let _ =\n    let result1 = lazy_sin_negatives [120.; 75.; 128.] in (* should return true *)\n    let result2 = lazy_sin_negatives [30.; 45.; 60.] in (* should return false *)\n    ()",
        "hint": "Use the `lazy` keyword for each angle's sine computation and `List.exists` with `Lazy.force`.",
        "explanation": "This problem requires you to create a list of lazy computations, so that the sine values are only computed when necessary. The function should utilize `List.exists` to short-circuit evaluation when it finds a negative sine, allowing you to avoid calculating all angles.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "73d41110-1fd9-4e3d-a1bc-67d120dd38ab",
        "chapter": "imperative-programming",
        "section": "Side Effects and Weak Polymorphism",
        "type": "multiple_choice",
        "question": "What does the underscore in the type variable '_weak1' signify in OCaml?",
        "choices": [
            "A) It indicates a type that can be instantiated to different types repeatedly.",
            "B) It signifies that the type is weakly polymorphic and can only hold a single type.",
            "C) It denotes an error in type inference.",
            "D) It is used to indicate mutable types only."
        ],
        "correct_answers": [
            1
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "The underscore in OCaml's type variable signifies weak polymorphism, meaning the variable can only be instantiated to one concrete type. This is in contrast to fully polymorphic types which can hold values of different types.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "01e6357d-0b0c-49c7-8fc8-fa31e735ccd8",
        "chapter": "imperative-programming",
        "section": "Side Effects and Weak Polymorphism",
        "type": "multiple_choice",
        "question": "Which expression will result in a weakly polymorphic type due to the value restriction?",
        "choices": [
            "A) let x = 3 in x",
            "B) List.map (fun x -> x * 2) [1; 2; 3]",
            "C) let f = (fun x -> [x; x])",
            "D) let list_init_10 = List.init 10 ~f:Int.to_string"
        ],
        "correct_answers": [
            3
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "The expression 'let list_init_10 = List.init 10 ~f:Int.to_string' results in a weakly polymorphic type due to the value restriction. This is because it cannot guarantee that 'List.init' doesn\u2019t introduce persistent mutable references, thus causing the result to be weakly polymorphic.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "fb496707-5466-42f7-9874-4ee3966ed8ce",
        "chapter": "imperative-programming",
        "section": "Side Effects and Weak Polymorphism",
        "type": "programming",
        "question": "Implement a function 'memoize' that caches results of a given function to optimize repeated calls with the same arguments. The function should accept two parameters: a function of type (int -> 'a) and an integer. It returns the cached result if available, or computes and caches the result otherwise.",
        "choices": [],
        "correct_answers": [],
        "starter_code": "let memoize f =\n    let cache = Hashtbl.create 10 in\n    fun x ->\n      match Hashtbl.find_opt cache x with\n      | Some v -> v\n      | None ->\n          let v = f x in\n          Hashtbl.add cache x v;\n          v",
        "test_code": "let square x = x * x;;\nlet cached_square = memoize square;;\n(* Testing the memoize function *)\nlet first_call = cached_square 4;; (* should return 16 *)\nlet second_call = cached_square 4;; (* should also return 16 and retrieve from cache *)\nlet third_call = cached_square 5;; (* should return 25 *)\n(* Expected output comments:\n   first_call = 16\n   second_call = 16\n   third_call = 25 *)",
        "hint": "Think about using a mutable data structure to store cached results and ensure you handle both finding in cache and storing new results correctly.",
        "explanation": "The 'memoize' function leverages a hash table for caching results of function calls, thereby optimizing repeated function evaluations with the same input. This approach is essential to enhance performance in scenarios where function calls are expensive.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "e91adc51-6e2d-4b82-8656-ea997dc84320",
        "chapter": "imperative-programming",
        "section": "The Value Restriction",
        "type": "multiple_choice",
        "question": "What is the main purpose of the value restriction in OCaml?",
        "choices": [
            "A) To ensure that all values are mutable",
            "B) To allow polymorphic types in certain expressions",
            "C) To restrict the use of functions in OCaml",
            "D) To optimize performance by limiting type inference"
        ],
        "correct_answers": [
            1
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "Consider how persistent mutable cells influence type inference in the language.",
        "explanation": "The value restriction primarily allows polymorphic types only in cases where a value cannot introduce persistent mutable state. This prevents incorrect type inferences in scenarios where details about statefulness aren't clear.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "ab64d7e2-1c1b-4efe-9774-1990a852db65",
        "chapter": "imperative-programming",
        "section": "The Value Restriction",
        "type": "multiple_choice",
        "question": "Which of the following expressions can be inferred as having a fully polymorphic type?",
        "choices": [
            "A) let f () = ref None",
            "B) let memoize f = ...",
            "C) let x = 5",
            "D) let add x y = x + y"
        ],
        "correct_answers": [
            0
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "Look for examples of expressions that don't utilize persistent mutable state.",
        "explanation": "The expression 'let f () = ref None' can be inferred as having a fully polymorphic type because it does not create any persistent mutable state that could potentially share values across different calls.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "ac1dd1b1-4e82-422f-86cc-adef9aeaef3f",
        "chapter": "imperative-programming",
        "section": "The Value Restriction",
        "type": "programming",
        "question": "Implement a function that takes a list of functions and returns a new function that, when called with a value, applies each function in the list to that value in sequence. This should handle polymorphic functions appropriately, ensuring that types are preserved correctly without introducing persistent mutable state.",
        "choices": [],
        "correct_answers": [],
        "starter_code": "let compose f_list =\n    (* your code here *)",
        "test_code": "let inc x = x + 1;;\nlet double x = x * 2;;\nlet f = compose [inc; double];;\nlet result = f 3;; (* should return 8, as (3 + 1) * 2 *) \n\nlet g = compose [double; inc];;\nlet result2 = g 3;; (* should return 7, as (3 * 2) + 1 *) \n\nlet h = compose [];;\nlet result3 = h 10;; (* should return 10, as no functions are applied *)",
        "hint": "Think about the nature of the list and how each function can be applied without causing mutable state issues. Consider leveraging OCaml's ability to handle higher-order functions effectively.",
        "explanation": "The `compose` function must take care to apply each function while maintaining the correct type, leveraging the value restriction to ensure no persistent mutable state is introduced while doing so.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "24ca6cc4-35d1-4ebf-8473-79b8cbb00dc1",
        "chapter": "imperative-programming",
        "section": "Partial Application and the Value Restriction",
        "type": "multiple_choice",
        "question": "What is the effect of the value restriction in OCaml when working with partially applied functions?",
        "choices": [
            "A) It ensures complete polymorphism can be inferred.",
            "B) It can limit function polymorphism under certain conditions.",
            "C) It always avoids type inference issues.",
            "D) It makes all functions non-fully applied."
        ],
        "correct_answers": [
            1
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "The value restriction can limit polymorphism in certain situations, particularly when dealing with partial applications. It arises because the system needs to ensure safety in variable usage, which can affect how functions behave when they are partially applied.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "a7e611b7-1060-48ad-93a7-d8ec726a747e",
        "chapter": "imperative-programming",
        "section": "Partial Application and the Value Restriction",
        "type": "multiple_choice",
        "question": "How can you achieve full polymorphism in a function that generates a list of length 10 in OCaml?",
        "choices": [
            "A) Use partial application of List.init only.",
            "B) Convert to a tail recursive function.",
            "C) Use eta expansion to avoid value restrictions.",
            "D) Define the function with mutable states."
        ],
        "correct_answers": [
            2
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "Using eta expansion allows the compiler to infer a polymorphic type instead of a weakly polymorphic one, removing the restrictions that arise from using partially applied functions.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "33e50155-a015-4c08-8e8b-cbe809a58f7c",
        "chapter": "imperative-programming",
        "section": "Partial Application and the Value Restriction",
        "type": "programming",
        "question": "Implement a function `create_fixed_list` that generates a list of a specified length, where each element is initialized by applying a given function to the index position, specifically for lists of length 10. Avoid partial application due to value restriction issues.",
        "choices": [],
        "correct_answers": [],
        "starter_code": "let create_fixed_list f = List.init 10 ~f;;",
        "test_code": "(* Test cases *)\nlet empty_strings = create_fixed_list (fun i -> \"\");; (* expected: [\"\"; \"\"; \"\"; \"\"; \"\"; \"\"; \"\"; \"\"; \"\"; \"\"] *)\nlet indexed_strings = create_fixed_list Int.to_string;; (* expected: [\"0\"; \"1\"; \"2\"; \"3\"; \"4\"; \"5\"; \"6\"; \"7\"; \"8\"; \"9\"] *)\nlet squares = create_fixed_list (fun i -> i * i);; (* expected: [0; 1; 4; 9; 16; 25; 36; 49; 64; 81] *)\nlet doubles = create_fixed_list (fun i -> i * 2);; (* expected: [0; 2; 4; 6; 8; 10; 12; 14; 16; 18] *)",
        "hint": "Remember, you need to define your function without using partial application of List.init to avoid the value restriction.",
        "explanation": "This function uses eta expansion to ensure that the compiler can infer a fully polymorphic type for the generated function instead of a weakly polymorphic type. Check more on eta expansion to understand its applications and importance.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "a3d03521-9fc5-4874-89f2-54037c09d373",
        "chapter": "imperative-programming",
        "section": "Relaxing the Value Restriction",
        "type": "multiple_choice",
        "question": "What does the relaxation of the value restriction in OCaml allow regarding polymorphic types?",
        "choices": [
            "A) All types are treated as mutable.",
            "B) Immutable types can be generalized to fully polymorphic types.",
            "C) Only concrete types can use polymorphic types.",
            "D) All function return types are immutable."
        ],
        "correct_answers": [
            1
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "The relaxation of the value restriction allows OCaml to infer fully polymorphic types for immutable types, enabling more flexibility with type usage in functional programming.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "91c31a6c-cbf3-41f6-a8f1-9bd62149ef91",
        "chapter": "imperative-programming",
        "section": "Relaxing the Value Restriction",
        "type": "multiple_choice",
        "question": "Which modification allows OCaml to infer polymorphic types when using abstract data types?",
        "choices": [
            "A) Marking the type variable as covariant.",
            "B) Making the type variable concrete.",
            "C) Removing all function applications.",
            "D) Using mutable types instead."
        ],
        "correct_answers": [
            0
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "",
        "explanation": "Marking the type variable as covariant in the type declaration allows OCaml to handle the abstract types properly and infer their polymorphisms.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "dc1b4270-5211-43fd-8441-5f85c1217a10",
        "chapter": "imperative-programming",
        "section": "Relaxing the Value Restriction",
        "type": "programming",
        "question": "Implement a OCaml module `Concat_list` that defines a simple immutable list type supporting constant-time concatenation using recursive types. The module must include functions for creating an empty list, creating a singleton list, concatenating two lists, and converting the list to a standard OCaml list. Also, ensure that the list type is treated as covariant to allow full polymorphism when necessary.",
        "choices": [],
        "correct_answers": [],
        "starter_code": "module Concat_list : sig\n  type +'a t\n  val empty : 'a t\n  val singleton : 'a -> 'a t\n  val concat : 'a t -> 'a t -> 'a t  (* constant time *)\n  val to_list : 'a t -> 'a list       (* linear time   *)\nend = struct\n  (* your code here *)\nend;;",
        "test_code": "let list1 = Concat_list.concat (Concat_list.singleton 1) (Concat_list.singleton 2);;\n(* should convert to: [1; 2] *)\nlet empty = Concat_list.empty;;\n(* should convert to: [] *)\nlet single = Concat_list.singleton 5;;\n(* should convert to: [5] *)\nlet list2 = Concat_list.concat (Concat_list.singleton 3) empty;;\n(* should convert to: [3] *)",
        "hint": "Consider using recursive types to define the underlying structure and ensure the interface exposes the type as covariant.",
        "explanation": "The implementation of `Concat_list` demonstrates how to maintain immutability and enable polymorphism through proper type annotations in OCaml, which is vital for type safety and functional programming.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "799d4197-9d57-4d64-9059-b1f0988b8742",
        "chapter": "imperative-programming",
        "section": "Summary",
        "type": "multiple_choice",
        "question": "What is the primary advantage of using immutable data structures in OCaml?",
        "choices": [
            "A) They are faster than mutable structures.",
            "B) They reduce the complexity of concurrent programming.",
            "C) They allow for improved memory management.",
            "D) They are easier to implement than mutable structures."
        ],
        "correct_answers": [
            1
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "Consider how immutability affects the state of data during program execution and its impact on thread safety.",
        "explanation": "The primary advantage of using immutable data structures in OCaml is that they reduce the complexity of concurrent programming, as immutable data can be shared without worrying about changes in state, making it easier to reason about code execution.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "5e3c55b7-1c14-45c1-8922-92d0c7e650d2",
        "chapter": "imperative-programming",
        "section": "Summary",
        "type": "multiple_choice",
        "question": "In OCaml, what do benign effects refer to?",
        "choices": [
            "A) Effects that do not modify the state of the program.",
            "B) Any function that produces no output.",
            "C) Side effects that can be safely ignored by the compiler.",
            "D) Imperative constructs that do not affect program safety."
        ],
        "correct_answers": [
            0
        ],
        "starter_code": "",
        "test_code": "",
        "hint": "Think about the implications of memoization and laziness in how functions operate in a side-effect-free context.",
        "explanation": "Benign effects refer to effects like memoization and laziness that do not modify the program state in an observable way, allowing for optimization without introducing risks of side effects.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    },
    {
        "id": "2f60838a-2da1-435f-804d-37c35c6e39c8",
        "chapter": "imperative-programming",
        "section": "Summary",
        "type": "programming",
        "question": "Implement a function that simulates a simple counter using mutable state in OCaml. The counter should allow incrementing, decrementing, and retrieving the current value. Demonstrate usage in your test cases.",
        "choices": [],
        "correct_answers": [],
        "starter_code": "type counter = { mutable value: int };;\nlet create_counter () = { value = 0 };;\nlet increment c = c.value <- c.value + 1;;\nlet decrement c = c.value <- c.value - 1;;\nlet get_value c = c.value;;",
        "test_code": "let c = create_counter ();;\nincrement c;; (* Counter should now be 1 *)\nlet v1 = get_value c;; (* v1 should be 1 *)\ndecrement c;; (* Counter should now be 0 *)\nlet v2 = get_value c;; (* v2 should be 0 *)\nincrement c;; increment c;; (* Counter should now be 2 *)\nlet v3 = get_value c;; (* v3 should be 2 *)",
        "hint": "Pay attention to the mutable record type and how you can modify its fields directly.",
        "explanation": "This question emphasizes understanding OCaml's mutable constructs. By using a mutable record for the counter, you can demonstrate how state changes occur in an imperative programming context. Exploring mutability's implications in OCaml can lead to better insights into when to effectively use mutable data.",
        "metadata": {
            "num_solves": 0,
            "is_deactivated": false,
            "quality_score": 5
        }
    }
]